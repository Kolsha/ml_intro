{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### This is first try intent classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import absolute_import\n",
    "from __future__ import division\n",
    "from __future__ import print_function\n",
    "\n",
    "import codecs\n",
    "import collections\n",
    "import json\n",
    "import re\n",
    "import numpy as np\n",
    "import modeling\n",
    "import tokenization\n",
    "import tensorflow as tf\n",
    "\n",
    "import pandas as pd\n",
    "\n",
    "import tokenization\n",
    "\n",
    "import sys\n",
    "\n",
    "from extract_features import InputExample, InputFeatures, input_fn_builder, model_fn_builder\n",
    "\n",
    "from extract_features import convert_examples_to_features, _truncate_seq_pair, read_examples\n",
    "\n",
    "tf.logging.set_verbosity(tf.logging.ERROR)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 -1\n"
     ]
    }
   ],
   "source": [
    "BERT_BASE_DIR = '/Users/kolsha/Documents/Projects/Python/BERT/multi_cased_L-12_H-768_A-12'\n",
    "\n",
    "init_checkpoint = BERT_BASE_DIR + '/bert_model.ckpt'\n",
    "\n",
    "layer_indexes = [-1]\n",
    "\n",
    "use_one_hot_embeddings = False\n",
    "\n",
    "max_seq_length = 128\n",
    "\n",
    "bert_config = modeling.BertConfig.from_json_file(BERT_BASE_DIR +'/bert_config.json')\n",
    "\n",
    "tokenizer = tokenization.FullTokenizer(\n",
    "      vocab_file=BERT_BASE_DIR+ '/vocab.txt', do_lower_case=False)\n",
    "\n",
    "for (j, layer_index) in enumerate(layer_indexes):\n",
    "    print(j, layer_index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "is_per_host = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n",
    "run_config = tf.contrib.tpu.RunConfig(\n",
    "  master=None,\n",
    "  tpu_config=tf.contrib.tpu.TPUConfig(\n",
    "      per_host_input_for_training=is_per_host)\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def convert_lines_to_examples(lines):\n",
    "    \"\"\"Read a list of `InputExample`s from an input file.\"\"\"\n",
    "    examples = []\n",
    "    unique_id = 0\n",
    "    for line in lines:\n",
    "        line = tokenization.convert_to_unicode(line)\n",
    "        if not line:\n",
    "            continue\n",
    "        line = line.strip()\n",
    "        text_a = None\n",
    "        text_b = None\n",
    "        m = re.match(r\"^(.*) \\|\\|\\| (.*)$\", line)\n",
    "        if m is None:\n",
    "            text_a = line\n",
    "        else:\n",
    "            text_a = m.group(1)\n",
    "            text_b = m.group(2)\n",
    "        examples.append(\n",
    "          InputExample(unique_id=unique_id, text_a=text_a, text_b=text_b))\n",
    "        unique_id += 1\n",
    "    return examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [],
   "source": [
    "model_fn = model_fn_builder(\n",
    "  bert_config=bert_config,\n",
    "  init_checkpoint=init_checkpoint,\n",
    "  layer_indexes=layer_indexes,\n",
    "  use_tpu=False,\n",
    "  use_one_hot_embeddings=use_one_hot_embeddings)\n",
    "\n",
    "estimator = tf.contrib.tpu.TPUEstimator(\n",
    "  use_tpu=False,\n",
    "  model_fn=model_fn,\n",
    "  config=run_config,\n",
    "  predict_batch_size=32)\n",
    "    \n",
    "def get_embeddings(lines):\n",
    "    result = []\n",
    "    \n",
    "    examples = convert_lines_to_examples(lines)\n",
    "    \n",
    "    features = convert_examples_to_features(\n",
    "      examples=examples, seq_length=max_seq_length, tokenizer=tokenizer)\n",
    "    \n",
    "    unique_id_to_feature = {}\n",
    "    for feature in features:\n",
    "        unique_id_to_feature[feature.unique_id] = feature\n",
    "    \n",
    "\n",
    "\n",
    "    input_fn = input_fn_builder(\n",
    "      features=features, seq_length=max_seq_length)\n",
    "    \n",
    "    pred = estimator.predict(input_fn, yield_single_examples=True)\n",
    "    \n",
    "    for p in pred:\n",
    "        #print(p['layer_output_0'].shape)\n",
    "        unique_id = int(p[\"unique_id\"])\n",
    "        feature = unique_id_to_feature[unique_id]\n",
    "        #print(feature.tokens)\n",
    "        layer_output = p[\"layer_output_0\"]\n",
    "        r = np.array([round(float(x), 6) for x in layer_output[0:1].flat])\n",
    "        result.append(r)\n",
    "    \n",
    "    return np.array(result)\n",
    "\n",
    "\n",
    "def predict_input(lines, estimator, lb_enc):\n",
    "    embeddings = get_embeddings(lines)\n",
    "    pred = estimator.predict(embeddings)\n",
    "    return lb_enc.inverse_transform(pred)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 174,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(2, 768)"
      ]
     },
     "execution_count": 174,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_embeddings(['Тест на ', 'Это был тест на ']).shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = pd.read_csv('intents.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "embeddings = get_embeddings(data['text'].values)\n",
    "print(embeddings.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn import preprocessing\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.metrics import f1_score\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.model_selection import StratifiedShuffleSplit\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Верните деньги',\n",
       " 'Как заблокировать сим-карту',\n",
       " 'Как заказать обратный звонок?',\n",
       " 'Как поменять домашний регион?',\n",
       " 'Как узнать кодовое слово?',\n",
       " 'Не приходят смс',\n",
       " 'Переведите на человека',\n",
       " 'Позвоните мне!',\n",
       " 'Почему вы подключаете услуги без моего согласия?',\n",
       " 'Что за  тарифный план?']"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "le = preprocessing.LabelEncoder()\n",
    "le.fit(data['label'].values)\n",
    "list(le.classes_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "Y = le.transform(data['label'].values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
      " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
      " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
      " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
      " 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
      " 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
      " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
      " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
      " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
      " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\n",
      " 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n",
      " 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n",
      " 8 8 8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n",
      " 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n",
      " 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n",
      " 5 5 5 5 5 5 5 5 5 5 5 5 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n",
      " 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n",
      " 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n",
      " 3 3 3 3 3 3 3 3 3 9 9 9 9 9 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n",
      " 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4\n",
      " 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n",
      " 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7 7\n",
      " 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n",
      " 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7]\n"
     ]
    }
   ],
   "source": [
    "print(Y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "forest = RandomForestClassifier(\n",
    "    criterion='entropy', n_estimators=400,\n",
    "#     max_features=None,\n",
    "    max_depth=17,\n",
    "    min_samples_leaf=2,\n",
    "    random_state=42)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "cv = StratifiedShuffleSplit(n_splits=10, random_state=42) #, shuffle=True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n",
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n",
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n",
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n",
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "BEST F1 Macro: 0.7565208890443331\n",
      "BEST F1 Micro: 0.7840909090909092\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    }
   ],
   "source": [
    "f1_mac_best = 0\n",
    "f1_mic_best = 0\n",
    "for (train, test) in cv.split(embeddings, Y):\n",
    "    forest.fit(embeddings[train], Y[train])\n",
    "    y_pred = forest.predict(embeddings[test])\n",
    "    \n",
    "    f1_mac = f1_score(Y[test], y_pred, average='macro')\n",
    "    f1_mic = f1_score(Y[test], y_pred, average='micro')\n",
    "#     print(\"F1 Macro: {}\".format(f1_mac) )\n",
    "#     print(\"F1 Micro: {}\".format(f1_mic) )\n",
    "    \n",
    "    if f1_mac > f1_mac_best:\n",
    "        f1_mac_best = f1_mac\n",
    "        f1_mic_best = f1_mic\n",
    "    \n",
    "print(\"BEST F1 Macro: {}\".format(f1_mac_best) )\n",
    "print(\"BEST F1 Micro: {}\".format(f1_mic_best) )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "BEST F1 Macro: 0.7565208890443331 <br/>\n",
    "BEST F1 Micro: 0.7840909090909092"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# xgboost"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xgboost as xgb"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0]\ttrain-merror:0.111534\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.035488\n",
      "[2]\ttrain-merror:0.024081\n",
      "[3]\ttrain-merror:0.013942\n",
      "[4]\ttrain-merror:0.010139\n",
      "[5]\ttrain-merror:0.00507\n",
      "[6]\ttrain-merror:0.002535\n",
      "[7]\ttrain-merror:0.002535\n",
      "[8]\ttrain-merror:0.002535\n",
      "[9]\ttrain-merror:0.002535\n",
      "[10]\ttrain-merror:0.002535\n",
      "[11]\ttrain-merror:0.002535\n",
      "[12]\ttrain-merror:0.001267\n",
      "[13]\ttrain-merror:0.001267\n",
      "[14]\ttrain-merror:0.001267\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0\n",
      "[18]\ttrain-merror:0\n",
      "[19]\ttrain-merror:0\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[17]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.6388946454062733\n",
      "F1 Micro: 0.7727272727272727\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1145: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no true samples.\n",
      "  'recall', 'true', average, warn_for)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0]\ttrain-merror:0.112801\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.045627\n",
      "[2]\ttrain-merror:0.022814\n",
      "[3]\ttrain-merror:0.015209\n",
      "[4]\ttrain-merror:0.010139\n",
      "[5]\ttrain-merror:0.010139\n",
      "[6]\ttrain-merror:0.00507\n",
      "[7]\ttrain-merror:0.006337\n",
      "[8]\ttrain-merror:0.002535\n",
      "[9]\ttrain-merror:0.002535\n",
      "[10]\ttrain-merror:0.002535\n",
      "[11]\ttrain-merror:0.001267\n",
      "[12]\ttrain-merror:0\n",
      "[13]\ttrain-merror:0\n",
      "[14]\ttrain-merror:0\n",
      "[15]\ttrain-merror:0\n",
      "[16]\ttrain-merror:0\n",
      "[17]\ttrain-merror:0\n",
      "[18]\ttrain-merror:0\n",
      "[19]\ttrain-merror:0\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[12]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.6981451187206429\n",
      "F1 Micro: 0.7727272727272727\n",
      "[0]\ttrain-merror:0.105196\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.035488\n",
      "[2]\ttrain-merror:0.015209\n",
      "[3]\ttrain-merror:0.011407\n",
      "[4]\ttrain-merror:0.008872\n",
      "[5]\ttrain-merror:0.003802\n",
      "[6]\ttrain-merror:0\n",
      "[7]\ttrain-merror:0.002535\n",
      "[8]\ttrain-merror:0.001267\n",
      "[9]\ttrain-merror:0\n",
      "[10]\ttrain-merror:0\n",
      "[11]\ttrain-merror:0\n",
      "[12]\ttrain-merror:0\n",
      "[13]\ttrain-merror:0\n",
      "[14]\ttrain-merror:0\n",
      "[15]\ttrain-merror:0\n",
      "[16]\ttrain-merror:0\n",
      "[17]\ttrain-merror:0\n",
      "[18]\ttrain-merror:0\n",
      "[19]\ttrain-merror:0\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[6]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.6559162285102268\n",
      "F1 Micro: 0.7386363636363636\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.6/site-packages/sklearn/metrics/classification.py:1143: UndefinedMetricWarning: F-score is ill-defined and being set to 0.0 in labels with no predicted samples.\n",
      "  'precision', 'predicted', average, warn_for)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0]\ttrain-merror:0.130545\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.053232\n",
      "[2]\ttrain-merror:0.026616\n",
      "[3]\ttrain-merror:0.017744\n",
      "[4]\ttrain-merror:0.012674\n",
      "[5]\ttrain-merror:0.008872\n",
      "[6]\ttrain-merror:0.003802\n",
      "[7]\ttrain-merror:0.003802\n",
      "[8]\ttrain-merror:0.003802\n",
      "[9]\ttrain-merror:0.003802\n",
      "[10]\ttrain-merror:0.002535\n",
      "[11]\ttrain-merror:0.002535\n",
      "[12]\ttrain-merror:0.002535\n",
      "[13]\ttrain-merror:0.002535\n",
      "[14]\ttrain-merror:0.002535\n",
      "[15]\ttrain-merror:0.002535\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0.001267\n",
      "[19]\ttrain-merror:0.001267\n",
      "[20]\ttrain-merror:0.001267\n",
      "[21]\ttrain-merror:0.001267\n",
      "[22]\ttrain-merror:0.001267\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "[49]\ttrain-merror:0\n",
      "[50]\ttrain-merror:0\n",
      "[51]\ttrain-merror:0\n",
      "[52]\ttrain-merror:0\n",
      "[53]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[23]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.7606829501095216\n",
      "F1 Micro: 0.7954545454545455\n",
      "[0]\ttrain-merror:0.096324\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.045627\n",
      "[2]\ttrain-merror:0.030418\n",
      "[3]\ttrain-merror:0.015209\n",
      "[4]\ttrain-merror:0.012674\n",
      "[5]\ttrain-merror:0.007605\n",
      "[6]\ttrain-merror:0.007605\n",
      "[7]\ttrain-merror:0.00507\n",
      "[8]\ttrain-merror:0.003802\n",
      "[9]\ttrain-merror:0.002535\n",
      "[10]\ttrain-merror:0.001267\n",
      "[11]\ttrain-merror:0.001267\n",
      "[12]\ttrain-merror:0.001267\n",
      "[13]\ttrain-merror:0.001267\n",
      "[14]\ttrain-merror:0.001267\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0\n",
      "[19]\ttrain-merror:0\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[18]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.6699841552782729\n",
      "F1 Micro: 0.7727272727272727\n",
      "[0]\ttrain-merror:0.112801\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.050697\n",
      "[2]\ttrain-merror:0.025349\n",
      "[3]\ttrain-merror:0.016477\n",
      "[4]\ttrain-merror:0.011407\n",
      "[5]\ttrain-merror:0.006337\n",
      "[6]\ttrain-merror:0.003802\n",
      "[7]\ttrain-merror:0.002535\n",
      "[8]\ttrain-merror:0.003802\n",
      "[9]\ttrain-merror:0.002535\n",
      "[10]\ttrain-merror:0.001267\n",
      "[11]\ttrain-merror:0.001267\n",
      "[12]\ttrain-merror:0.001267\n",
      "[13]\ttrain-merror:0.001267\n",
      "[14]\ttrain-merror:0.001267\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0.001267\n",
      "[19]\ttrain-merror:0.001267\n",
      "[20]\ttrain-merror:0.001267\n",
      "[21]\ttrain-merror:0.001267\n",
      "[22]\ttrain-merror:0.001267\n",
      "[23]\ttrain-merror:0.001267\n",
      "[24]\ttrain-merror:0.001267\n",
      "[25]\ttrain-merror:0.001267\n",
      "[26]\ttrain-merror:0.001267\n",
      "[27]\ttrain-merror:0.001267\n",
      "[28]\ttrain-merror:0.001267\n",
      "[29]\ttrain-merror:0.001267\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "[49]\ttrain-merror:0\n",
      "[50]\ttrain-merror:0\n",
      "[51]\ttrain-merror:0\n",
      "[52]\ttrain-merror:0\n",
      "[53]\ttrain-merror:0\n",
      "[54]\ttrain-merror:0\n",
      "[55]\ttrain-merror:0\n",
      "[56]\ttrain-merror:0\n",
      "[57]\ttrain-merror:0\n",
      "[58]\ttrain-merror:0\n",
      "[59]\ttrain-merror:0\n",
      "[60]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[30]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.7886792739424319\n",
      "F1 Micro: 0.8295454545454547\n",
      "[0]\ttrain-merror:0.111534\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.045627\n",
      "[2]\ttrain-merror:0.019011\n",
      "[3]\ttrain-merror:0.012674\n",
      "[4]\ttrain-merror:0.010139\n",
      "[5]\ttrain-merror:0.007605\n",
      "[6]\ttrain-merror:0.006337\n",
      "[7]\ttrain-merror:0.006337\n",
      "[8]\ttrain-merror:0.006337\n",
      "[9]\ttrain-merror:0.00507\n",
      "[10]\ttrain-merror:0.003802\n",
      "[11]\ttrain-merror:0.006337\n",
      "[12]\ttrain-merror:0.00507\n",
      "[13]\ttrain-merror:0.003802\n",
      "[14]\ttrain-merror:0.001267\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0.001267\n",
      "[19]\ttrain-merror:0.001267\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "[49]\ttrain-merror:0\n",
      "[50]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[20]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.819804920434346\n",
      "F1 Micro: 0.8522727272727273\n",
      "[0]\ttrain-merror:0.116603\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.050697\n",
      "[2]\ttrain-merror:0.026616\n",
      "[3]\ttrain-merror:0.017744\n",
      "[4]\ttrain-merror:0.012674\n",
      "[5]\ttrain-merror:0.006337\n",
      "[6]\ttrain-merror:0.006337\n",
      "[7]\ttrain-merror:0.007605\n",
      "[8]\ttrain-merror:0.002535\n",
      "[9]\ttrain-merror:0.001267\n",
      "[10]\ttrain-merror:0.002535\n",
      "[11]\ttrain-merror:0.002535\n",
      "[12]\ttrain-merror:0.001267\n",
      "[13]\ttrain-merror:0.001267\n",
      "[14]\ttrain-merror:0\n",
      "[15]\ttrain-merror:0\n",
      "[16]\ttrain-merror:0\n",
      "[17]\ttrain-merror:0\n",
      "[18]\ttrain-merror:0\n",
      "[19]\ttrain-merror:0\n",
      "[20]\ttrain-merror:0\n",
      "[21]\ttrain-merror:0\n",
      "[22]\ttrain-merror:0\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[14]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.6681509090865816\n",
      "F1 Micro: 0.7613636363636364\n",
      "[0]\ttrain-merror:0.108999\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.057034\n",
      "[2]\ttrain-merror:0.021546\n",
      "[3]\ttrain-merror:0.016477\n",
      "[4]\ttrain-merror:0.010139\n",
      "[5]\ttrain-merror:0.010139\n",
      "[6]\ttrain-merror:0.007605\n",
      "[7]\ttrain-merror:0.00507\n",
      "[8]\ttrain-merror:0.00507\n",
      "[9]\ttrain-merror:0.00507\n",
      "[10]\ttrain-merror:0.003802\n",
      "[11]\ttrain-merror:0.00507\n",
      "[12]\ttrain-merror:0.00507\n",
      "[13]\ttrain-merror:0.003802\n",
      "[14]\ttrain-merror:0.002535\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0.001267\n",
      "[19]\ttrain-merror:0.001267\n",
      "[20]\ttrain-merror:0.001267\n",
      "[21]\ttrain-merror:0.001267\n",
      "[22]\ttrain-merror:0.001267\n",
      "[23]\ttrain-merror:0\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "[49]\ttrain-merror:0\n",
      "[50]\ttrain-merror:0\n",
      "[51]\ttrain-merror:0\n",
      "[52]\ttrain-merror:0\n",
      "[53]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[23]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.7885275218608553\n",
      "F1 Micro: 0.8522727272727273\n",
      "[0]\ttrain-merror:0.091255\n",
      "Will train until train-merror hasn't improved in 30 rounds.\n",
      "[1]\ttrain-merror:0.032953\n",
      "[2]\ttrain-merror:0.012674\n",
      "[3]\ttrain-merror:0.008872\n",
      "[4]\ttrain-merror:0.003802\n",
      "[5]\ttrain-merror:0.002535\n",
      "[6]\ttrain-merror:0.002535\n",
      "[7]\ttrain-merror:0.002535\n",
      "[8]\ttrain-merror:0.001267\n",
      "[9]\ttrain-merror:0.001267\n",
      "[10]\ttrain-merror:0.001267\n",
      "[11]\ttrain-merror:0.001267\n",
      "[12]\ttrain-merror:0.001267\n",
      "[13]\ttrain-merror:0.001267\n",
      "[14]\ttrain-merror:0.001267\n",
      "[15]\ttrain-merror:0.001267\n",
      "[16]\ttrain-merror:0.001267\n",
      "[17]\ttrain-merror:0.001267\n",
      "[18]\ttrain-merror:0.001267\n",
      "[19]\ttrain-merror:0.001267\n",
      "[20]\ttrain-merror:0.001267\n",
      "[21]\ttrain-merror:0.001267\n",
      "[22]\ttrain-merror:0.001267\n",
      "[23]\ttrain-merror:0.001267\n",
      "[24]\ttrain-merror:0\n",
      "[25]\ttrain-merror:0\n",
      "[26]\ttrain-merror:0\n",
      "[27]\ttrain-merror:0\n",
      "[28]\ttrain-merror:0\n",
      "[29]\ttrain-merror:0\n",
      "[30]\ttrain-merror:0\n",
      "[31]\ttrain-merror:0\n",
      "[32]\ttrain-merror:0\n",
      "[33]\ttrain-merror:0\n",
      "[34]\ttrain-merror:0\n",
      "[35]\ttrain-merror:0\n",
      "[36]\ttrain-merror:0\n",
      "[37]\ttrain-merror:0\n",
      "[38]\ttrain-merror:0\n",
      "[39]\ttrain-merror:0\n",
      "[40]\ttrain-merror:0\n",
      "[41]\ttrain-merror:0\n",
      "[42]\ttrain-merror:0\n",
      "[43]\ttrain-merror:0\n",
      "[44]\ttrain-merror:0\n",
      "[45]\ttrain-merror:0\n",
      "[46]\ttrain-merror:0\n",
      "[47]\ttrain-merror:0\n",
      "[48]\ttrain-merror:0\n",
      "[49]\ttrain-merror:0\n",
      "[50]\ttrain-merror:0\n",
      "[51]\ttrain-merror:0\n",
      "[52]\ttrain-merror:0\n",
      "[53]\ttrain-merror:0\n",
      "[54]\ttrain-merror:0\n",
      "Stopping. Best iteration:\n",
      "[24]\ttrain-merror:0\n",
      "\n",
      "F1 Macro: 0.664981572288399\n",
      "F1 Micro: 0.7386363636363636\n",
      "BEST F1 Macro: 0.819804920434346\n",
      "BEST F1 Micro: 0.8522727272727273\n"
     ]
    }
   ],
   "source": [
    "f1_mac_best = 0\n",
    "f1_mic_best = 0\n",
    "for (train, test) in cv.split(embeddings, Y):\n",
    "#     forest.fit(embeddings[train], Y[train])\n",
    "#     y_pred = forest.predict(embeddings[test])\n",
    "    \n",
    "    xg_train = xgb.DMatrix(embeddings[train], label=Y[train])\n",
    "    xg_test = xgb.DMatrix(embeddings[test], label=Y[train])\n",
    "    # setup parameters for xgboost\n",
    "    param = {\n",
    "            'n_estimators': 300,\n",
    "            'max_depth': 6,\n",
    "            'objective': 'multi:softmax',\n",
    "            'learning_rate': 0.05,\n",
    "            'subsample': 0.9,\n",
    "            'colsample_bytree': 0.9\n",
    "            #'eta': 0.1, \n",
    "            }\n",
    "\n",
    "    param['silent'] = 1\n",
    "    param['nthread'] = 4\n",
    "    param['num_class'] = len(le.classes_)\n",
    "\n",
    "    watchlist = [(xg_train, 'train')]#, (xg_test, 'test')\n",
    "    num_round = 300\n",
    "    bst = xgb.train(param, xg_train, num_round, watchlist, early_stopping_rounds=30)\n",
    "    # get prediction\n",
    "    y_pred = bst.predict(xg_test)\n",
    "#     print(y_pred)\n",
    "#     print(Y[test])\n",
    "#     break\n",
    "    \n",
    "    f1_mac = f1_score(Y[test], y_pred, average='macro')\n",
    "    f1_mic = f1_score(Y[test], y_pred, average='micro')\n",
    "    print(\"F1 Macro: {}\".format(f1_mac) )\n",
    "    print(\"F1 Micro: {}\".format(f1_mic) )\n",
    "    \n",
    "    if f1_mac > f1_mac_best:\n",
    "        f1_mac_best = f1_mac\n",
    "        f1_mic_best = f1_mic\n",
    "    \n",
    "print(\"BEST F1 Macro: {}\".format(f1_mac_best) )\n",
    "print(\"BEST F1 Micro: {}\".format(f1_mic_best) )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "BEST F1 Macro: 0.819804920434346 <br/>\n",
    "BEST F1 Micro: 0.8522727272727273\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import GridSearchCV"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'nthread': [4], 'objective': ['multi:softmax'], 'reg_alpha': [0, 0.5], 'reg_lambda': [0, 0.5], 'gamma': [0, 0.5], 'subsample': [0.7, 1], 'colsample_bytree': [0.7, 1], 'max_depth': [1, 9, 20], 'learning_rate': [0.05], 'n_estimators': [100, 500]}\n"
     ]
    }
   ],
   "source": [
    "\n",
    "params_grid_xgb = {\n",
    "          'nthread':[4],\n",
    "          'objective': ['multi:softmax'],\n",
    "          'reg_alpha': [0, 0.5],\n",
    "          'reg_lambda': [0, 0.5],\n",
    "          'gamma': [0, 0.5],\n",
    "          'subsample': [0.7, 1],\n",
    "          'colsample_bytree':[0.7, 1],\n",
    "          'max_depth': [1, 9, 20],\n",
    "          'learning_rate': [0.05],\n",
    "          'n_estimators': [100, 500]\n",
    "}\n",
    "\n",
    "xgb_model = xgb.XGBClassifier()\n",
    "\n",
    "\n",
    "clf = GridSearchCV(xgb_model, params_grid_xgb, n_jobs=-1, \n",
    "                   cv=cv, \n",
    "#                    scoring='roc_auc',\n",
    "                   verbose=True, refit=True)\n",
    "print(params_grid_xgb)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "clf.fit(embeddings, Y)\n",
    "print(\"Fit end\")\n",
    "print(clf.best_params_, clf.best_score_)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# LogisticRegression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LogisticRegression\n",
    "logreg = LogisticRegression(random_state=42, solver='lbfgs',\n",
    "                            multi_class='multinomial', max_iter=3000)\n",
    "import copy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 177,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "BEST F1 Macro: 0.9699559699559699\n",
      "BEST F1 Micro: 0.9772727272727273\n",
      "AVG  F1 Macro: 0.9108337910413408\n"
     ]
    }
   ],
   "source": [
    "f1_mac_best = 0\n",
    "f1_mic_best = 0\n",
    "best_logreg = None\n",
    "f1_mac_avg = 0\n",
    "f1_mac_avg_count = 0\n",
    "for (train, test) in cv.split(embeddings, Y):\n",
    "    logreg.fit(embeddings[train], Y[train])\n",
    "    y_pred = logreg.predict(embeddings[test])\n",
    "    \n",
    "    f1_mac = f1_score(Y[test], y_pred, average='macro')\n",
    "    f1_mic = f1_score(Y[test], y_pred, average='micro')\n",
    "    \n",
    "    f1_mac_avg += f1_mac\n",
    "    f1_mac_avg_count += 1\n",
    "#     print(\"F1 Macro: {}\".format(f1_mac) )\n",
    "#     print(\"F1 Micro: {}\".format(f1_mic) )\n",
    "    \n",
    "    if f1_mac > f1_mac_best:\n",
    "        best_logreg = copy.copy(logreg)\n",
    "        f1_mac_best = f1_mac\n",
    "        f1_mic_best = f1_mic\n",
    "    \n",
    "print(\"BEST F1 Macro: {}\".format(f1_mac_best) )\n",
    "print(\"BEST F1 Micro: {}\".format(f1_mic_best) )\n",
    "\n",
    "f1_mac_avg = float(f1_mac_avg) / float(f1_mac_avg_count)\n",
    "print(\"AVG  F1 Macro: {}\".format(f1_mac_avg) )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 178,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,\n",
       "          intercept_scaling=1, max_iter=3000, multi_class='multinomial',\n",
       "          n_jobs=None, penalty='l2', random_state=42, solver='lbfgs',\n",
       "          tol=0.0001, verbose=0, warm_start=False)"
      ]
     },
     "execution_count": 178,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "best_logreg.fit(embeddings, Y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 179,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Как заблокировать сим-карту' 'Как заблокировать сим-карту'\n",
      " 'Как поменять домашний регион?' 'Верните деньги' 'Верните деньги'\n",
      " 'Переведите на человека']\n"
     ]
    }
   ],
   "source": [
    "samples = [\n",
    "    'Здравствуйте, меня зовут Павел, я не понимаю, как можно заблокировать симкарту?',\n",
    "    'СОС, ХЕЛП, нужно срочно блокнуть симку, СРОЧНО',\n",
    "    'Алоха, как восстановить симкарту?', # bad sample\n",
    "    \n",
    "    'Это снова Павел, где мои деньги, негодяи?',\n",
    "    'Ребят, случайно отправил деньги не туда',\n",
    "    \n",
    "    'А ты точно человек, а скажи чтонибудь по человечьи?'\n",
    "]\n",
    "print(predict_input(samples, best_logreg, le))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.externals import joblib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['best_logreg_29_1_19']"
      ]
     },
     "execution_count": 138,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "joblib.dump(best_logreg, \"best_logreg_29_1_19\", compress=9)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {},
   "outputs": [],
   "source": [
    "VK_API_ACCESS_TOKEN = 'aada2900ca3b69e310739de830ea662e44cf4d159bbeffc7259edc21382a28d811b89cf52dca486642830'  # Ключ доступа сообщества (для получения адреса сервера)\n",
    "GROUP_ID = 177447412          # ID группы, должны быть в ней администратором\n",
    "VK_API_VERSION = '5.74'\t  # Используемая версия VK API"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 180,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "message_new\n",
      "message_new\n",
      "message_new\n",
      "message_new\n",
      "message_new\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/urllib3/connectionpool.py\u001b[0m in \u001b[0;36m_make_request\u001b[0;34m(self, conn, method, url, timeout, chunked, **httplib_request_kw)\u001b[0m\n\u001b[1;32m    376\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m  \u001b[0;31m# Python 2.7, use buffering of HTTP responses\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 377\u001b[0;31m                 \u001b[0mhttplib_response\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgetresponse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbuffering\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    378\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m:\u001b[0m  \u001b[0;31m# Python 3\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: getresponse() got an unexpected keyword argument 'buffering'",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-180-60a2b7316251>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     16\u001b[0m                                          \u001b[0;34m'ts'\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mts\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m                                          \u001b[0;34m'wait'\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m                                          'version': 2}).json()\n\u001b[0m\u001b[1;32m     19\u001b[0m     \u001b[0mts\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlongPoll\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'ts'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mlongPoll\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'updates'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlongPoll\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'updates'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/requests/api.py\u001b[0m in \u001b[0;36mpost\u001b[0;34m(url, data, json, **kwargs)\u001b[0m\n\u001b[1;32m    114\u001b[0m     \"\"\"\n\u001b[1;32m    115\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 116\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0mrequest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'post'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0murl\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdata\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mjson\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mjson\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    117\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    118\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/requests/api.py\u001b[0m in \u001b[0;36mrequest\u001b[0;34m(method, url, **kwargs)\u001b[0m\n\u001b[1;32m     58\u001b[0m     \u001b[0;31m# cases, and look like a memory leak in others.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     59\u001b[0m     \u001b[0;32mwith\u001b[0m \u001b[0msessions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSession\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0msession\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 60\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0msession\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrequest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmethod\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmethod\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0murl\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0murl\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     61\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     62\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/requests/sessions.py\u001b[0m in \u001b[0;36mrequest\u001b[0;34m(self, method, url, params, data, headers, cookies, files, auth, timeout, allow_redirects, proxies, hooks, stream, verify, cert, json)\u001b[0m\n\u001b[1;32m    531\u001b[0m         }\n\u001b[1;32m    532\u001b[0m         \u001b[0msend_kwargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msettings\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 533\u001b[0;31m         \u001b[0mresp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mprep\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0msend_kwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    534\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    535\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mresp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/requests/sessions.py\u001b[0m in \u001b[0;36msend\u001b[0;34m(self, request, **kwargs)\u001b[0m\n\u001b[1;32m    644\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    645\u001b[0m         \u001b[0;31m# Send the request\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 646\u001b[0;31m         \u001b[0mr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0madapter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrequest\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    647\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    648\u001b[0m         \u001b[0;31m# Total elapsed time of the request (approximately)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/requests/adapters.py\u001b[0m in \u001b[0;36msend\u001b[0;34m(self, request, stream, timeout, verify, cert, proxies)\u001b[0m\n\u001b[1;32m    447\u001b[0m                     \u001b[0mdecode_content\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    448\u001b[0m                     \u001b[0mretries\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax_retries\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 449\u001b[0;31m                     \u001b[0mtimeout\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtimeout\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    450\u001b[0m                 )\n\u001b[1;32m    451\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/urllib3/connectionpool.py\u001b[0m in \u001b[0;36murlopen\u001b[0;34m(self, method, url, body, headers, retries, redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\u001b[0m\n\u001b[1;32m    598\u001b[0m                                                   \u001b[0mtimeout\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtimeout_obj\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    599\u001b[0m                                                   \u001b[0mbody\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mbody\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mheaders\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 600\u001b[0;31m                                                   chunked=chunked)\n\u001b[0m\u001b[1;32m    601\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    602\u001b[0m             \u001b[0;31m# If we're going to release the connection in ``finally:``, then\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/lib/python3.6/site-packages/urllib3/connectionpool.py\u001b[0m in \u001b[0;36m_make_request\u001b[0;34m(self, conn, method, url, timeout, chunked, **httplib_request_kw)\u001b[0m\n\u001b[1;32m    378\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m:\u001b[0m  \u001b[0;31m# Python 3\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    379\u001b[0m                 \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 380\u001b[0;31m                     \u001b[0mhttplib_response\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconn\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgetresponse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    381\u001b[0m                 \u001b[0;32mexcept\u001b[0m \u001b[0mException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    382\u001b[0m                     \u001b[0;31m# Remove the TypeError from the exception chain in Python 3;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36mgetresponse\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1329\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1330\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1331\u001b[0;31m                 \u001b[0mresponse\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbegin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1332\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mConnectionError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1333\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36mbegin\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    295\u001b[0m         \u001b[0;31m# read until we get a non-100 response\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    296\u001b[0m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 297\u001b[0;31m             \u001b[0mversion\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstatus\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreason\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_read_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    298\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mstatus\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mCONTINUE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    299\u001b[0m                 \u001b[0;32mbreak\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/http/client.py\u001b[0m in \u001b[0;36m_read_status\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    256\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    257\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_read_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 258\u001b[0;31m         \u001b[0mline\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreadline\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_MAXLINE\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"iso-8859-1\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    259\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0m_MAXLINE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    260\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mLineTooLong\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"status line\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socket.py\u001b[0m in \u001b[0;36mreadinto\u001b[0;34m(self, b)\u001b[0m\n\u001b[1;32m    584\u001b[0m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    585\u001b[0m             \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 586\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sock\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrecv_into\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    587\u001b[0m             \u001b[0;32mexcept\u001b[0m \u001b[0mtimeout\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    588\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_timeout_occurred\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/ssl.py\u001b[0m in \u001b[0;36mrecv_into\u001b[0;34m(self, buffer, nbytes, flags)\u001b[0m\n\u001b[1;32m   1007\u001b[0m                   \u001b[0;34m\"non-zero flags not allowed in calls to recv_into() on %s\"\u001b[0m \u001b[0;34m%\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1008\u001b[0m                   self.__class__)\n\u001b[0;32m-> 1009\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnbytes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1010\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1011\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0msocket\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrecv_into\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnbytes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mflags\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/ssl.py\u001b[0m in \u001b[0;36mread\u001b[0;34m(self, len, buffer)\u001b[0m\n\u001b[1;32m    869\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Read on closed or unwrapped SSL socket.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    870\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 871\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sslobj\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    872\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mSSLError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    873\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mSSL_ERROR_EOF\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msuppress_ragged_eofs\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/ssl.py\u001b[0m in \u001b[0;36mread\u001b[0;34m(self, len, buffer)\u001b[0m\n\u001b[1;32m    629\u001b[0m         \"\"\"\n\u001b[1;32m    630\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mbuffer\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 631\u001b[0;31m             \u001b[0mv\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sslobj\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    632\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    633\u001b[0m             \u001b[0mv\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sslobj\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "import vk\n",
    "from requests import *\n",
    "import os\n",
    "\n",
    "session = vk.Session(access_token = VK_API_ACCESS_TOKEN)\n",
    "api = vk.API(session, v = VK_API_VERSION)\n",
    "\n",
    "# Первый запрос к LongPoll: получаем server и key\n",
    "longPoll = api.groups.getLongPollServer(group_id = GROUP_ID)\n",
    "\n",
    "server, key, ts = longPoll['server'], longPoll['key'], longPoll['ts']\n",
    "while True:\n",
    "    # Последующие запросы: меняется только ts\n",
    "    longPoll = post('%s'%server, data = {'act': 'a_check',\n",
    "                                         'key': key,\n",
    "                                         'ts': ts,\n",
    "                                         'wait': 1,\n",
    "                                         'version': 2}).json()\n",
    "    ts = longPoll['ts']\n",
    "    if longPoll['updates'] and len(longPoll['updates']) != 0:\n",
    "        for update in longPoll['updates']:\n",
    "            if update['type'] == 'message_new':\n",
    "                print('message_new')\n",
    "                # Помечаем сообщение от этого пользователя как прочитанное\n",
    "                api.messages.markAsRead(peer_id = update['object']['user_id'])\n",
    "                api.messages.setActivity(peer_id = update['object']['user_id'], type='typing', group_id = GROUP_ID)\n",
    "                text = update['object']['body']\n",
    "                name = api.users.get(user_ids = update['object']['user_id'])[0]['first_name']\n",
    "                res  = predict_input([text], best_logreg, le)\n",
    "                api.messages.send(peer_id = update['object']['user_id'],\n",
    "                                  message = 'Привет, {} &#128521; \\n {}'.format(name, res[0]))\n",
    "                break\n",
    "\n",
    "\n",
    "    # Меняем ts для следующего запроса\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
